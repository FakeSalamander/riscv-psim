

mod subcomponents {
use bin::isa;

pub struct PCMux<T> {
    added_pc_in : T,
    result_in : u32,

    count_out : T,
    count_out_chk : bool,

    pc_adder_ptr : &PCAdder<T>,
    alu_ptr : &ALUnit,

    //decider not implemented yet.
}


pub struct ProgramCounter<T> {
    count_in : T,

    count_out : T,
    count_out_chk : bool,

    pc_mux_ptr : &PCMux<T>
}

impl<T> ProgramCounter<T> {
    pub fn grab_input(&mut self) {
        if self.pc_mux_ptr.count_out_chk {
            self.count_in = self.pc_mux_ptr.count_out;
        } else {
            panic!("ProgramCounter tried to update its count before count-ouput from the PCMux could be sent");
        }
    }
    pub fn update_count(&mut self) {
        self.count_out = self.count_in;   //doesn't do much more than store the PC.
        self.count_out_chk = true;
    }
}


pub struct PCAdder<T> {
    count_in : T,

    count_out : T,
    count_out_chk : bool,

    pc_ptr : &ProgramCounter<T>
}

impl<T> PCAdder<T> {
    pub fn grab_input(&mut self) {
        if pc_ptr.count_out_chk {
            self.count_in = self.pc_ptr.count_out;
        } else {
            panic!("PCAdder tried to update its count before count-output from the ProgramCounter could be sent");
        }
    }
    pub fn add_count(&mut self) {
        self.count_out = self.count_in + 4;   //simply increments the program count by 4, so it points to the next instruction.
        self.count_out_chk = true;
    }
}


pub struct InstrMem<T> {
    ins_addr_in : T,

    ins_array : Vec<T>,

    instruction_out : u32,
    instruction_out_chk : bool,

    pc_ptr : &ProgramCounter<T>
}

impl<T> InstrMem<T> {
    pub fn grab_input(&mut self) {
        if self.pc_ptr.count_out_chk {
            self.ins_addr_in = self.pc_ptr.count_out;
        } else {
            panic!("PCAdder tried to update its count before count-output from the ProgramCounter could be sent");        
        }
    }
    pub fn fetch_instruction(&mut self) { //fetches the 32-bit instruction the PC refers to,
        self.instruction_out = self.ins_array[self.ins_addr_in/4]; //the first [0] instruction is at address 0, the next [1] is at address 4, the next [2] at address 8, so on.
        self.instruction_out_chk = true;
    }
}

//The <T> in the previous objects is dependent on the instruction memory size that the user chooses. Unsigned Int of varying size.

pub struct IFIDLatch<T> {
    base_pc_in : T,
    base_pc_out : T,
    base_pc_out_chk : bool, 

    added_pc_in : T,
    added_pc_out : T,
    added_pc_out_chk : bool,

    instruction_in : u32, 
    instruction_out : u32,
    instruction_out_chk : bool,

    pc_ptr : &ProgramCounter<T>,
    pc_adder_ptr : &PCAdder<T>,
    instr_mem_ptr : &InstrMem<T>,
}

impl<T> IFIDLatch<T> {
    pub fn grab_input (&mut self) {
        if !(self.pc_ptr.count_out_chk) {
            panic!("IF-ID Latch tried to update its base_pc before count-output from the ProgramCounter could be sent");  
        } else if !(self.pc_adder_ptr.count_out_chk) {
            panic!("IF-ID Latch tried to update its added_pc before count-output from the PCAdder could be sent");  
        } else if !(self.instr_mem_ptr.instruction_out_chk) {
            panic!("IF-ID Latch tried to update its instruction before instr-output from the InstrMeme could be sent");
        } else {
            self.base_pc_in = self.pc_ptr.count_out;
            self.added_pc_in = self.pc_adder_ptr.count_out;
            self.instruction_in = self.instr_mem_ptr.instruction_out;
        }
    }
    pub fn open_latch (&mut self) {  //opens the latch to let new values pass through.
        self.base_pc_out = self.base_pc_in;
        self.added_pc_out = self.base_pc_in;
        self.instruction_out = self.instruction_in;

        self.base_pc_out_chk = true;
        self.added_pc_out_chk = true;
        self.instruction_out_chk =true;
    }
}

pub struct InstrDecoder {
    instruction_in : u32,
    ifid_latch_ptr : &IFIDLatch<u32>,

    opcode_out : u8, //7-bit opcode
    opcode_out_chk : bool,

    r1_index_out : u8, //5-bit register index
    r1_index_out_chk : bool,

    r2_index_out : u8,
    r2_index_out_chk : bool,

    rd_index_out : u8,
    rd_index_out_chk : bool,

    //won't be displayed!
    funct3_out : u8,
    funct3_out_chk : bool,
    funct7_out : u8,
    funct7_out_chk : bool,
}

impl InstrDecoder {
    pub fn grab_input(&mut self) {
        if (self.ifid_latch_ptr.instruction_out_chk) {
            self.instruction_in = self.ifid_latch_ptr.instruction_out;
        } else {
            panic!("InstrDecoder tried to update its instruction before IF-ID Latch could send it.");
        }
    }
    pub fn decode(&mut self) { //gets the opcode, r1 index, r2 index, and destination register index out of the instruction, even if they end up being unused.

        //uses bit-wise AND operation on a mask in order to get the desired bits, dividing to rem

        // need to get lowest 7 bits out, just use a mask to get (6-0)
        self.opcode_out = (self.instruction_in & 0b1111111 ) as u8;
        self.opcode_out_chk =true;

        // need to get bits (19-15) out. use mask, then shift right all the zero'd bits
        self.r1_index_out = ((self.instruction_in & 0b11111000000000000000) >> 15) as u8;
        self.r1_index_out_chk = true;

        // need to get bits (24-20) out.  
        self.r2_index_out = ((self.instruction_in & 0b1111100000000000000000000) >> 20) as u8;
        self.r2_index_out_chk = true;

        // need to get bits (11-7) out. 
        self.rd_index_out = ((self.instruction_in & 0b111110000000) >> 7) as u8;
        self.rd_index_out_chk = true;

        // need to get the bits (14-12) out.
        self.funct3_out = ((self.instruction_in & 0b111000000000000) >> 12) as u8;
        self.funct3_out_chk = true;

        //need to get the bits (31-25) out.
        self.funct7_out = ((self.instruction_in & 0b111111100000000000000000000000000) >> 25) as u8;
        self.funct7_out_chk = true;
    }
}


pub struct RegMem {
    r1_index_in : u8,
    r2_index_in : u8,

    rd_index_in : u8,

    wb_data_in : u32,  //this is the writeback data from 3 steps ago, getting commited to the register

    registers : Vec<u32>, //the value of each corresponds to what that register name points to. 0 always points to 0 constant, and is unused.

    //real_registers : Vec<u32> //each of these correspodns to a real physical register! NOT IMPLEMENTED YET

    r1_data_out : u32,
    r1_data_out_chk : bool,
    r2_data_out : u32,
    r2_data_out_chk : bool,
    
    instr_dec_ptr : &InstrDecoder,
    memwb_latch_ptr : &MEMWBLatch<u32>,
    wb_mux_ptr : &WBMux,
}

impl RegMem {
    pub fn grab_input(&mut self) {
        if !(self.instr_dec_ptr.r1_index_out_chk && self.instr_dec_ptr.r2_index_out_chk) {
            panic!("RegMem tried to grab R1 and R2 indices from Instruction Decoder before it was ready.");
        } else if !(self.memwb_latch_ptr.rd_index_out_chk) {
            panic!("RegMem tried to grab destination register index from the MEM-WB Latch before it was ready.");
        } else if !(self.wb_mux_ptr.wb_data_out_chk) {
            panic!("RegMem tried to grab the writeback data from the WB Mux before it was ready.");
        } else {
            self.r1_index_in = self.instr_dec_ptr.r1_index_out;
            self.r2_index_in = self.instr_dec_ptr.r2_index_out;
            
            self.rd_index_in = self.memwb_latch_ptr.rd_index_out;
            
            self.wb_data_in = self.wb_mux_ptr.wb_data_out;
        }
    }

    pub fn write_data(&mut self) {
        if (self.rd_index_in == 0) {
            panic!("The $0 register holds a constant zero value! It cannot be written to.");
        }
        self.registers[self.rd_index_in as usize] = self.wb_data_in;
    }

    pub fn fetch_registers(&mut self) {
        self.r1_data_out = self.registers[self.r1_index_in as usize];
        self.r1_data_out_chk = true;

        self.r2_data_out = self.registers[self.r2_index_in as usize];
        self.r2_data_out_chk = true;
    }
}

pub struct ImmDecoder {
    opcode_in : u8,
    instr_dec_ptr : &InstrDecoder,

    instruction_in : u32,
    ifid_latch_ptr : &IFIDLatch<u32>,

    immediates_out : u32,
    immediates_out_chk : bool,
}

impl ImmDecoder {
    pub fn grab_input (&mut self) {
        if !(self.instr_dec_ptr.opcode_out_chk) {
            panic!("ImmDecoder tried to grab opcode before InstrDecoder was ready!");
        } else if !(self.ifid_latch_ptr.instruction_out_chk) {
            panic!("ImmDecoder tried to grab instruction before IF-ID Latch was ready!");
        } else {
            self.opcode_in = self.instr_dec_ptr.opcode_out;
            self.instruction_in = self.ifid_latch_ptr.instruction_out;
        }
    }

    pub fn decode (&mut self) { //rearranges the immediates of an instruction by type, so they're where the ALU expects them.
        let instr_type : isa::InstrType = isa::get_instruction_type(self.opcode_in);

        if (instr_type == isa::Rtype) {
            // Does nothing!?
        } else if (instr_type == isa::Itype) { //in this one, simply put the last 12 bits of instruction all the way at the left!
            self.immediates_out = ((self.instruction_in as i32) >> 20) as u32 ;
        } else if (instr_type == isa::Stype) { //(31-25) goes to [11-5],  (11-7) goes to [4-0]. do each separately, then bitwise OR

            //                       the (31-25) is converted to signed so that it does an arithmetic right shift
            self.immediates_out = ((((self.instruction_in & 0b11111110000000000000000000000000) as i32) >> 20)as u32) | ((self.instruction_in & 0b111110000000) >> 7);
        } else if (instr_type == isa::Btype) { //A (31) to [12] ,B (30-25) to [10-5], C (11-8) to [4-1], D (7) to [11]
            let imm_a : u32 = (self.instruction_in & 0b100000000000000000000000000000000) >> 19;
            let imm_b : u32 = (self.instruction_in & 0b011111100000000000000000000000000) >> 20;
            let imm_c : u32 = (self.instruction_in & 0b000000000000000000000111100000000) >> 7;
            let imm_d : u32 = (self.instruction_in & 0b000000000000000000000000010000000) << 4;

            self.immediates_out = ((((imm_a | imm_b | imm_c | imm_d) << 20) as i32) >> 20) as u32 ; //the wonky shifting just sign-extends the 12-bit Imm preemptively
        } else if (instr_type = isa::Utype) { //(31-12) goes to [31-12]... so just mask the rest!
            self.immediates_out = self.instruction_in & 0b11111111111111111111000000000000;
        } else { //only J-type left!  E  (31) to [20], F  (30-21) to [10-1], G  (20) to [11],  H  (19-12) to [19-12]
             let imm_e : u32 = (self.instruction_in & 0b100000000000000000000000000000000) >> 11;
             let imm_f : u32 = (self.instruction_in & 0b011111111110000000000000000000000) >> 20;
             let imm_g : u32 = (self.instruction_in & 0b000000000001000000000000000000000) >> 9;
             let imm_h : u32 = (self.instruction_in & 0b000000000000111111110000000000000);

             self.immediates_out = ((((imm_e | imm_f | imm_g | imm_h) << 12) as i32) >> 12) as u32 ; //same here, sign-shifts the 20-bit Imm
        }

        self.immediates_out_chk = true;
    }
}

pub struct IDEXLatch<T> {
    base_pc_in : T,
    base_pc_out : T,
    base_pc_out_chk : bool, 

    added_pc_in : T,
    added_pc_out : T,
    added_pc_out_chk : bool,

    r1_data_in : u32,
    r1_data_out : u32,
    r1_data_out_chk : bool,

    r2_data_in : u32,
    r2_data_out : u32,
    r2_data_out_chk : bool,

    immediates_in : u32,
    immediates_out : u32,
    immediates_out_chk : bool,

    rd_index_in : u8,
    rd_index_out : u8,
    rd_index_out_chk : bool,

    ifid_latch_ptr : &IFIDLatch<T>,
    reg_mem_ptr : &RegMem,
    imm_dec_ptr : &ImmDecoder,
    instr_dec_ptr : &InstrDecoder,

    //these won't be displayed on interface!
    opcode_in : u8,
    opcode_out : u8,
    opcode_out_chk : bool,

    funct3_in : u8,
    funct3_out : u8,
    funct3_out_chk : bool,

    funct7_in : u8,
    funct7_out : u8,
    funct7_out_chk : bool,

    r1_index_in : u8,
    r1_index_out : u8,
    r1_index_out_chk : bool,

    r2_index_in : u8,
    r2_index_out : u8,
    r2_index_out_chk : bool,
}

impl<T> IDEXLatch<T> {
    pub fn grab_input (&mut self ) {
        if !(self.ifid_latch_ptr.base_pc_out_chk && self>ifid_latch_ptr.added_pc_out_chk) {
            panic!("ID-EX Latch tried to grab the program counts from IF-ID Latch before it was ready!");
        } else if !(self.reg_mem_ptr.r1_data_out_chk && self.reg_mem_ptr.r2_data_out_chk) {
            panic!("ID-EX Latch tried to grab the R1 and R2 data from the RegMem before it was ready!");
        } else if !(self.imm_dec_ptr.immediates_out_chk) {
            panic!("ID-EX Latch tried to grab the immediates from ImmDecoder before it was ready!");
        } else if !(self.instr_dec_ptr.rd_index_out_chk && self.instr_dec_ptr.r1_index_out_chk && self.instr_dec_ptr.r2_index_out_chk) {
            panic!("ID-EX Latch tried to grab the R1, R2, and RD index from InstrDecoder before it was ready!");
        } else if !(self.instr_dec_ptr.opcode_out_chk && self.instr_dec_ptr.funct3_out_chk && self.instr_dec_ptr.funct7_out_chk) {
            panic!("ID-EX latch tried to grab the opcode and funct-codes from InstrDecoder before it was ready!")
        } else {
            self.base_pc_in = self.ifid_latch_ptr.base_pc_out;
            self.added_pc_in = self.ifid_latch_ptr.added_pc_out;
            self.r1_data_in = self.reg_mem_ptr.r1_data_out;
            self.r2_data_in = self.reg_mem_ptr.r2_data_out;
            self.immediates_in = self.imm_dec_ptr.immediates_out;
            self.rd_index_in = self.instr_dec_ptr.rd_index_out;

            self.opcode_in = self.instr_dec_ptr.opcode_out;
            self.funct3_in = self.instr_dec_ptr.funct3_out;
            self.funct7_in = self.instr_dec_ptr.funct7_out;
            self.r1_index_in = self.instr_dec_ptr.r1_index_out;
            self.r2_index_in = self.instr_dec_ptr.r2_index_out;
        }
    }

    pub fn open_latch(&mut self) {
        self.base_pc_out = self.base_pc_in;
        self.added_pc_out = self.added_pc_in;
        self.r1_data_out = self.r1_data_in;
        self.r2_data_out = self.r2_data_in;
        self.immediates_out = self.immediates_in;
        self.rd_index_out = self.rd_index_in;

        self.base_pc_out_chk = true;
        self.added_pc_out_chk = true;
        self.r1_data_out_chk = true;
        self.r2_data_out_chk = true;
        self.immediates_out_chk = true;
        self.rd_index_out_chk = true;

        self.opcode_out = self.opcode_in;
        self.opcode_out_chk = true;
        
        self.funct3_out = self.funct3_in;
        self.funct3_out_chk = true;

        self.funct7_out = self.funct7_in;
        self.funct7_out_chk = true;

        self.r1_index_out = self.r1_index_in;
        self.r1_index_out_chk = true;

        self.r2_index_out = self.r2_index_in;
        self.r2_index_out_chk = true;
    }
}


//I dont understand how these work, so I'll leave them be for now.
pub struct R1ForMux {
    normal_r1_in : u32, //from IDEX latch
    exex_r1_in : u32, //from EX-MEM latch
    memex_r1_in : u32, //from WB Mux

    r1_out : u32, 
    r1_out_chk : bool,

    idex_latch_ptr : &IDEXLatch<u32>,
    exmem_latch_ptr : &EXMEMLatch<u32>,
    memwb_latch_ptr : &MEMWBLatch<u32>,
    wb_mux_ptr : &WBMux,

    //not shown on GUI
    exex_rd_in : u8,  //from EX-MEM latch
    memex_rd_in : u8, //from MEM-WB latch
    r1_index_in : u8, //from ID-EX latch
}

impl R1ForMux {
    pub fn grab_input(&mut self) {
        if !(self.idex_latch_ptr.r1_data_out_chk && self.idex_latch_ptr.r1_index_out_chk) {
            panic!("R1-Forwarding Mux tried grabbing normal R1 data, R1 index before ID-EX Latch was ready!");
        } else if !(self.exmem_latch_ptr.rd_index_out_chk && self.exmem_latch_ptr.result_out_chk) {
            panic!("R1-Forwarding Mux tried grabbing  ex-ex forwarding RD index & ex-ex R1 data before EX-MEM Latch was ready!");
        } else if !(self.memwb_latch_ptr.rd_index_out_chk) {
            panic!("R1-Forwarding Mux tried grabbing mem-ex forwarding RD index before MEM-WB Latch was ready!");
        } else if !(self.wb_mux_ptr.wb_data_out_chk) {
            panic!("R1-Forwarding Mux tried grabbing mem-ex R1 data before WB Mux was ready!");
        } else {
            self.normal_r1_in = self.idex_latch_ptr.r1_data_out;
            self.exex_r1_in = self.exmem_latch_ptr.result_out;
            self.memex_r1_in = self.wb_mux_ptr.wb_data_out;
            
            self.exex_rd_in = self.exmem_latch_ptr.rd_index_out;
            self.memex_rd_in = self.memwb_latch_ptr.rd_index_out;
            self.r1_index_in = self.idex_latch_ptr.r1_index_out;
        }
    }

    pub fn decide(&mut self) {
        if (self.r1_index_in == self.exex_rd_in) { //if the output of the previous instruction is the input of this one...
            self.r1_out = self.exex_r1_in;
        } else if (self.r1_index_in == self.memex_rd_in) {//if the output of the 2nd-previous instruction is the input of this one...
            self.r1_out = self.memex_r1_in;
        } else {// otherwise, proceed as normal.
            self.r1_out = self.normal_r1_in;
        }
        self.r1_out_chk = true;
    }
}

pub struct R2ForMux {
    normal_r2_in : u32, //from IDEX latch
    exex_r2_in : u32, //from EX-MEM latch
    memex_r2_in : u32, //from WB Mux

    r2_out : u32, 
    r2_out_chk : bool,

    idex_latch_ptr : &IDEXLatch<u32>,
    exmem_latch_ptr : &EXMEMLatch<u32>,
    memwb_latch_ptr : &MEMWBLatch<u32>,
    wb_mux_ptr : &WBMux,

    //not shown on GUI
    exex_rd_in : u8,  //from EX-MEM latch
    memex_rd_in : u8, //from MEM-WB latch
    r2_index_in : u8, //from ID-EX latch
}

impl R2ForMux {
    pub fn grab_input(&mut self) {
        if !(self.idex_latch_ptr.r2_data_out_chk && self.idex_latch_ptr.r2_index_out_chk) {
            panic!("R2-Forwarding Mux tried grabbing normal R2 data, R2 index before ID-EX Latch was ready!");
        } else if !(self.exmem_latch_ptr.rd_index_out_chk && self.exmem_latch_ptr.result_out_chk) {
            panic!("R2-Forwarding Mux tried grabbing  ex-ex forwarding RD index & ex-ex R2 data before EX-MEM Latch was ready!");
        } else if !(self.memwb_latch_ptr.rd_index_out_chk) {
            panic!("R2-Forwarding Mux tried grabbing mem-ex forwarding RD index before MEM-WB Latch was ready!");
        } else if !(self.wb_mux_ptr.wb_data_out_chk) {
            panic!("R2-Forwarding Mux tried grabbing mem-ex R2 data before WB Mux was ready!");
        } else {
            self.normal_r2_in = self.idex_latch_ptr.r2_data_out;
            self.exex_r2_in = self.exmem_latch_ptr.result_out;
            self.memex_r2_in = self.wb_mux_ptr.wb_data_out;
            
            self.exex_rd_in = self.exmem_latch_ptr.rd_index_out;
            self.memex_rd_in = self.memwb_latch_ptr.rd_index_out;
            self.r2_index_in = self.idex_latch_ptr.r2_index_out;
        }
    }

    pub fn decide(&mut self) {
        if (self.r2_index_in == self.exex_rd_in) { //if the output of the previous instruction is the input of this one...
            self.r2_out = self.exex_r2_in;
        } else if (self.r2_index_in == self.memex_rd_in) {//if the output of the 2nd-previous instruction is the input of this one...
            self.r2_out = self.memex_r2_in;
        } else {// otherwise, proceed as normal.
            self.r2_out = self.normal_r2_in;
        }
        self.r2_out_chk = true;
    }
}
//////
/// 
/// 
/// 
pub struct R1PCMux {
    r1_in : u32,
    pc_in : u32,
    opcode_in : u8,

    op1_out : u32,
    op1_out_chk : bool,

    idex_latch_ptr : &IDEXLatch<u32>,
    r1for_mux_ptr : &R1ForMux,
}

impl R1PCMux {
    pub fn grab_input(&mut self) {
        if !(self.idex_latch_ptr.opcode_out_chk && self.idex_latch_ptr.base_pc_out_chk) {
            panic!("R1-PC Mux tried to get opcode and PC from ID-EX Latch before it was ready!");
        } else if !(self.r1for_mux_ptr.r1_out_chk) {
            panic!("R1-PC Mux tried to get R1 data from R1-Forward Mux before it was read!");
        } else {
            self.r1_in = self.r1for_mux_ptr.r1_out;
            self.pc_in = self.idex_latch_ptr.base_pc_out;
            self.opcode_in = self.idex_latch_ptr.opcode_out;
        }
    }

    pub fn decide(&mut self) {
        let instr_type : isa::InstrType = isa::get_instruction_type(self.opcode_in);

        if (instr_type == isa::Utype || instr_type == isa::Jtype || instr_type == isa::Btype) {
            self.op1_out = self.pc_in;
        } else {
            self.op1_out = self.r1_in;
        }
        self.op1_out_chk = true;
    }
}

pub struct R2ImmMux {
    r2_in : u32,
    immediates_in : u32,
    opcode_in : u8,

    op2_out : u32,
    op2_out_chk : bool,

    idex_latch_ptr : &IDEXLatch<u32>,
    r2for_mux_ptr : &R2ForMux,
}

impl R2ImmMux {
    pub fn grab_input(&mut self) {
        if !(self.idex_latch_ptr.opcode_out_chk && self.idex_latch_ptr.immediates_out_chk) {
            panic!("R2-PC Mux tried to get opcode and Immediates from ID-EX Latch before it was ready!");
        } else if !(self.r2for_mux_ptr.r2_out_chk) {
            panic!("R2-PC Mux tried to get R2 data from R2-Forward Mux before it was read!");
        } else {
            self.r2_in = self.r2for_mux_ptr.r2_out;
            self.immediates_in = self.idex_latch_ptr.immediates_out;
            self.opcode_in = self.idex_latch_ptr.opcode_out;
        }
    }

    pub fn decide(&mut self) {
        let instr_type : isa::InstrType = isa::get_instruction_type(self.opcode_in);

        if (instr_type == isa::Rtype) {
            self.op2_out = self.r2_in;
        } else {
            self.op2_out = self.immediates_in;
        }
        self.op2_out_chk = true;
    }
}



pub struct BranchComparator {
    r1_in : u32,
    r2_in : u32,

    branches_out : bool,
    branches_out_chk : bool,

    r1for_mux_ptr : &R1ForMux,
    r2for_mux_ptr : &R2ForMux,
    
    //wont be displayed
    funct3_in : u8,
    idex_latch_ptr : &IDEXLatch<u32>,
}

impl BranchComparator {
    pub fn grab_input(&mut self) {
        if !(self.r1for_mux_ptr.r1_out_chk) {
            panic!("BranchComparator tried getting R1 value before R1-Forward Mux was ready!");
        } else if !(self.r2for_mux_ptr.r2_out_chk) {
            panic!("BranchComparator tried getting R2 value before R2-Forward Mux was ready!");
        } else if !(self.idex_latch_ptr.funct3_out_chk) {
            panic!("BranchComparator tried getting funct3-code before ID-EX Latch was ready!");
        } else {
            self.r1_in = self.r1for_mux_ptr.r1_out;
            self.r2_in = self.r2for_mux_ptr.r2_out;

            self.funct3_in = self.idex_latch_ptr.funct3_out;
        }
    }

    pub fn compare(&mut self) { // Checks based off the 3bit funct3-code and R1 & R2, if the instruction is a Branch, whether a branch happens or not.
        self.branches_out = match self.funct3_in {
            0b000 => (self.r1_in == self.r2_in); //BEQ
            0b001 => (self.r1_in != self.r2_in); //BNE
            0b100 => ((self.r1_in as i32) <  (self.r2_in as i32)); //BLT
            0b101 => ((self.r1_in as i32) >  (self.r2_in as i32)); //BGE
            0b110 => (self.r1_in <  self.r2_in); //BLTU
            0b111 => (self.r1_in >  self.r2_in); //BGEU
            _ => false; //not a branching instruction.
        };
    }
}

pub struct ALUnit {
    op1_in : u32,
    op2_in : u32,

    result_out : u32,
    result_out_chk : bool,

    r1pc_mux_ptr : &R1PCMux,
    r2imm_mux_ptr : &R2ImmMux,

    //not listed on GUI!
    opcode_in : u8,
    funct3_in : u8,
    funct7_in : u8,
    idex_latch_ptr : &IDEXLatch<u32>,
}

impl ALUnit {
    pub fn grab_input(&mut self) {
        if !(self.r1pc_mux_ptr.op1_out_chk) {
            panic!("ALU tried grabbing Op1 before R1-PC Mux was ready!");
        } else if !(self.r2imm_mux_ptr.op2_out_chk) {
            panic!("ALU tried grabbing Op2 before R2-Imm Mux was ready!");
        } else if !(self.idex_latch_ptr.opcode_out_chk && self.idex_latch_ptr.funct3_out_chk && self.idex_latch_ptr.funct7_out_chk) {
            panic!("ALU tried grabbing opcode & funct-codes before IDEX Latch was ready!");
        } else {
            self.op1_in = self.r1pc_mux_ptr.op1_out;
            self.op2_in = self.r2imm_mux_ptr.op2_out;
            
            self.opcode_in = self.idex_latch_ptr.opcode_out;
            self.funct3_in = self.idex_latch_ptr.funct3_out;
            self.funct7_in = self.idex_latch_ptr.funct7_out;
        }
    }

    pub fn compute(&mut self) { //actually computes the instruction!  for signed operations, convert Ops to signed then convert result to unsigned.

        self.result_out = match self.opcode_in {
            0b0110111 => self.op2_in, //LUI, just put in immediate as is
            0b0010111 => self.op1_in + self.op2_in,  //AUIPC, add PC and Imm, store in RD
            0b1101111 => ((self.op1_in as i32) + (self.op2_in as i32)) as u32,  //JAL, add PC and Imm, store in RD, jump there
            0b1100011 => ((self.op1_in as i32) + (self.op2_in as i32)) as u32,//Branches. Perform signed addition between PC and Imm to figure out new PC.
            0b0000011 => ((self.op1_in as i32) + (self.op2_in as i32)) as u32,// LB/LH/LW, add R1 and Imm offset to get source memory address.
            0b0100011 => ((self.op1_in as i32) + (self.op2_in as i32)) as u32,// SB/SH/SW, add R1 and Imm offset to get destination memory address. R2 goes straight to Mem (thru EX-MEM latch).
            0b0010011 => match self.funct3_in { //Register-Immediate instructions
                0b000 => ((self.op1_in as i32) + (self.op2_in as i32)) as u32,//ADDI, siggned add R1 and Imm 
                0b010 => if ((self.op1_in as i32) < (self.op2_in as i32)) {1} else {0}, //STLI, check if R1 < Imm
                0b011 => if (self.op1_in < self.op2_in) {1} else {0}, //STLIU, STLI but unsigned.
                0b100 => self.op1_in ^ self.op2_in, //XORI, bitwise exclusive-or on R1 and Imm.
                0b110 => self.op1_in | self.op2_in, //ORI, bitwise or on R1 and Imm.
                0b111 => self.op1_in & self.op2_in, //ANDI, bitwise and on R1 and Imm.
                0b001 => if (self.op2_in > 31) {panic!} else {self.op1_in << self.op2_in} // SLLI, shift R1 left by  shamt ([4-0] of Imm) bits.
                0b101 => match (self.op2_in >> 5) {
                    0b0000000 => self.op1_in >> self.op2_in, //SRLI, shift R1 right logically by shamt bits
                    0b0100000 => ((self.op1_in as i32) >> ((self.op2_in - 0b010000000000) as i32)) as u32, //SRAI, shift R1 right arithmetically by shamt bits
                    _ => panic!("Invalid upper Imm. bits for Right Shift Instruction!"),
                }
                _ => panic!("funct3-code is bigger than 3 bits! this shouldnt happen!!!"),
            }
            0b0110011 => match self.funct3_in { //Register-Register instructions
                0b000 => match self.funct7_in {
                    0b0000000 => ((self.op1_in as i32) + (self.op2_in as i32)) as u32, //ADD
                    0b0100000 => ((self.op1_in as i32) - (self.op2_in as i32)) as u32, //SUB
                    _ => panic!("Invalid funct7 for ADD/SUB instruction"),
                }
                0b001 => self.op1_in << (self.op2_in & 0b11111), //SLL, shift left logical. Shift R1 left by the lowest 5 bits of R2
                0b010 => if ((self.op1_in as i32) < (self.op2_in as i32)) {1} else {0}, //SLT,  signed less than
                0b011 => if (self.op1_in < self.op2_in) {1} else {0}, //SLTU, unsigned less than
                0b100 => self.op1_in ^ self.op2_in, //XOR, bitwise exclusive or
                0b101 => match self.funct7_in {
                    0b0000000 => self.op1_in >> (self.op2_in & 0b11111), //SRL, shift right logical. Shift R1 logically right by the lowest 5 bits or R2
                    0b0100000 => ((self.op1_in as i32) >> (self.op2_in & 0b11111)) as u32, //SRA, shift right arithmetic.
                    _ => panic!("Invalid upper Imm. bits for Right Shift Instruction!"),
                }
                0b110 => self.op1_in | self.op2_in, //OR, bitwise or
                0b111 => self.op1_in & self.op2_in, //AND, bitwise and
                _ => panic!("funct3-code is bigger than 3 bits! this shouldnt happen!!!"),
            }
            _ => panic!("Invalid or Unimplemented Instruction!"),
        };
        self.result_out_chk = true;
    }
}

pub struct EXMEMLatch<T> {
    added_pc_in : T,
    added_pc_out : T,
    added_pc_out_chk : bool,
    
    result_in : u32,
    result_out : u32,
    result_out_chk : bool,

    mem_data_in : u32,
    mem_data_out : u32,
    mem_data_out_chk : bool,
    
    rd_index_in : u8,
    rd_index_out : u8,
    rd_index_out_chk : bool,

    idex_latch_ptr : &IDEXLatch<T>,
    alu_ptr : &ALUnit,
    r2for_mux_ptr : &R2ForMux,

    //won't be officially shown
    opcode_in : u8,
    opcode_out : u8,
    opcode_out_chk : bool,

    funct3_in : u8,
    funct3_out : u8,
    funct3_out_chk : bool,
}

impl<T> EXMEMLatch<T> {
    pub fn grab_input(&mut self) {
        if !(self.idex_latch_ptr.added_pc_out_chk && self.idex_latch_ptr.rd_index_out_chk && self.idex_latch_ptr.opcode_out_chk & self.idex_latch_ptr.funct3_out_chk) {
            panic!("EX-MEM Latch tried grabbing added PC, RD index, Funct3, & opcode before ID-EX Latch was ready!");
        } else if !(self.alu_ptr.result_out_chk) {
            panic!("EX-MEM Latch tried grabbing computation result before the ALU was ready!");
        } else if !(self.r2for_mux_ptr.r2_out_chk) {
            panic!("EX-MEM Latch tried grabbing Memory-Data-In from R2 Index ");
        } else {
            self.added_pc_in = self.idex_latch_ptr.added_pc_out;
            self.result_in = self.alu_ptr.result_out;
            self.mem_data_in = self.r2for_mux_ptr.r2_out;
            self.rd_index_in = self.idex_latch_ptr.rd_index_out;

            self.opcode_in = self.idex_latch_ptr.opcode_out;
            self.funct3_in - self.idex_latch_ptr.funct3_out;
        }
    }

    pub fn open_latch(&mut self) {
        self.added_pc_out = self.added_pc_in;
        self.added_pc_out_chk = true;

        self.result_out = self.result_in;
        self.result_out_chk = true;

        self.mem_data_out = self.mem_data_in;
        self.mem_data_out_chk = true;

        self.rd_index_out = self.rd_index_in;
        self.rd_index_out_chk = true;

        self.opcode_out = self.opcode_in;
        self.opcode_out_chk = true;
        self.funct3_out = self.funct3_in;
        self.funct3_out_chk = true;
    }
}


pub struct DataMem { //just a shell object for the data-memory subcomponents to interact with rest of Processor. Not implemented yet.
    address_in : u32,
    data_in : u32,

    mem_read_out : u32,
    mem_read_out_chk : bool,

    exmem_latch_ptr : &EXMEMLatch<u32>,

    //wont be officially shown!
    opcode_in : u8,
    funct3_in : u8
}

///
/// 
/// 

pub struct MEMWBLatch<T> {
    added_pc_in : T,
    added_pc_out : T,
    added_pc_out_chk : bool,
    
    result_in : u32,
    result_out : u32,
    result_out_chk : bool,

    mem_read_in : u32,
    mem_read_out : u32,
    mem_read_out_chk : bool,
    
    rd_index_in : u8,
    rd_index_out : u8,
    rd_index_out_chk : bool,

    exmem_latch_ptr : &IDEXLatch<T>,
    data_mem_ptr : &DataMem,

    //won't be officially shown
    opcode_in : u8,
    opcode_out : u8,
    opcode_out_chk : bool,
}

impl<T> MEMWBLatch<T> {
    self grab_input(&mut self) {
        if !(self.exmem_latch_ptr.added_pc_out_chk && self.exmem_latch_ptr.result_out_chk && self.exmem_latch_ptr.rd_index_out_chk && self.exmem_latch_ptr.opcode_out_chk) {
            panic!("MEM-WB Latch tried grabbing Added PC, Computation Result, Destination Index, or Opcode before EX-MEM Latch was ready!");
        } else if !(self.data_mem_ptr.mem_read_out_chk) {
            panic!("MEM-WB Latch tried grabbing Memory Read output before the Data Memory was ready!");
        } else {
            self.added_pc_in = self.exmem_latch_ptr.added_pc_out;
            self.result_in = self.exmem_latch_ptr.result_out;
            self.mem_read_in = self.data_mem_ptr.mem_read_out;
            self.rd_index_in = self.exmem_latch_ptr.rd_index_out;

            self.opcode_in = self.exmem_latch_ptr.opcode_out; 
        }
    }

    self open_latch(&mut self) {
        self.added_pc_out = self.added_pc_in;
        self.added_pc_out_chk = true;

        self.result_out = self.result_in;
        self.result_out_chk = true;

        self.mem_read_out = self.mem_read_in;
        self.mem_read_out_chk = true;

        self.rd_index_out = self.rd_index_in;
        self.rd_index_out_chk = true;

        self.opcode_out = self.opcode_in;
        self.opcode_out_chk = true;
    }
}

pub struct WBMux {
    added_pc_in : u32,
    result_in : u32,
    mem_read_in : u32,  

    wb_data_out : u32,
    wb_data_out_chk : bool,

    memwb_latch_ptr : &MEMWBLatch<u32>,
    //not in GUI
    opcode_in : u8,
}

impl WBMux {
    pub fn grab_input(&mut self) {
        if !(self.memwb_latch_ptr.added_pc_out_chk && self.memwb_latch_ptr.result_out_chk && self.memwb_latch_ptr.mem_read_out_chk && self.memwb_latch_ptr.opcode_out_chk) {
            panic!("WB Multiplexor tried to grab Added PC, Computation Result, Memory Read Data, and Opcode from MEM-WB Latch before it was ready!");
        } else {
            self.added_pc_in = self.memwb_latch_ptr.added_pc_out;
            self.result_in = self.memwb_latch_ptr.result_in;
            self.mem_read_in = self.memwb_latch_ptr.mem_read_out;
            
            self.opcode_in - self.memwb_latch_ptr.opcode_out;
        }
    }

    pub fn decide(&mut self) {
        if (self.opcode_in == 0b11011111 || self.opcode_in == 0b1100111) { //JAL, JALR, store (pc+4) into RD
            self.wb_data_out = self.added_pc_in;
        } else if (self.opcode_in == 0b0000011) { // LB, LH, LW, LBU, LHU. The load instructions all load the memory read data into RD
            self.wb_data_out = self.mem_read_in;
        } else if (self.opcode_in == 0b1100011 && self.opcode_in == 0b0100011) { // Branches & Stores. These write nothing to RD at all!
            self.wb_data_out = 0xdeadbeef; //special value representing null
        } else { //all other opcodes return the ALU's result to the RD
            self.wb_data_out = self.result_in;
        }
        self.wb_data_out_chk = true;
    }
}

}

#[cfg(test)]
mod tests {
    #[test]
    fn program_counter() {
        let mut pcmux : PCMux = PCMUx<u32> {
            added_pc_in : 0,
            result_in: 0,

            count_out: 64,
            count_out_chk: true,
        }

        let mut pc : ProgramCounter<u32> {
            count_in : 0,

            count_out : 32,
            count_out_chk : false,

            pc_mux_ptr : &pcmux,
        }

        pc.update_count();

        assert_eq!(pc.count_out, 64);
        assert!(count_out_chk);
    }
}